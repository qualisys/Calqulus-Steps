const { markdownFmt } = require('../../build/main/lib/utils/template-literal-tags')

// Replicating anchor links generated by Azure Devops wiki.
const adoSlug = (value) => {
	return encodeURIComponent(value.trim().replace(/\s/g, '-').toLowerCase());
}

const kebabCase = string => string
	.replace(/([a-z])([A-Z])/g, "$1-$2")
	.replace(/[\s_]+/g, '-')
	.toLowerCase();

const renderStepIndexPage = (globalProps, categories) => {
	let output = '';

	const orderedCategories = Object.keys(categories).sort();

	const categoryLinks = orderedCategories.reduce((rows, category) => {
		rows += `- [${ category }](./${ kebabCase(category) }.md)\n`;
		return rows;
	}, '');

	const sharedOptions = (!globalProps.options) ? '' : globalProps.options.reduce((rows, option) => {
		rows += renderOption(option);
		rows += '\n';

		return rows;
	}, '');

	output += markdownFmt`
		# Step nodes

		${ globalProps.description }
		
		## Step node categories

		${ categoryLinks }

		## Shared options

		The following options is available on all steps and regards 
		common tasks like data exports.

		${ sharedOptions }
	`;

	return output;
}

const renderStepCategoryPage = (category, steps, globalProps) => {
	let output = '';

	// Add title
	output += `# ${ category.name } steps\n\n`;
	
	// Add TOC
	for (const step of steps) {
		let aliases = '';
		if (step.alias) {
			if (Array.isArray(step.alias)) {
				aliases = ` / ${ step.alias.join(' / ') }`;
			} else {
				aliases = ` / ${ step.alias }`;
			}
		}
		output += `- [${ step.name }${ aliases }](#${ adoSlug(step.name) })\n`;
	}
	
	if (category.description) {
		output += `\n${ category.description }\n`;
	}

	if (category.examples) {
		output += `\n## Examples\n\n${ category.examples }\n`;
	}

	if (category.options && category.options.length) {
		output += `\n## Shared options\n\n`;

		output += `The following option${ (category.options.length === 1) ? ' is' : 's are' } available on all ${ category.name } steps.\n\n`;

		for (const option of category.options) {
			output += renderOption(option);
		}

		output += `>\n`;
	}
	
	// Render steps
	output += `\n\n---\n\n`;
	output += `## Steps\n\n`;
	
	for (const step of steps) {
		output += `### \`${ step.name }\`\n\n`;

		let aliases = '';
		if (step.alias) {
			if (Array.isArray(step.alias)) {
				aliases = `**Alias:** ${ step.alias.join(' / ') }`;
			} else {
				aliases = `**Alias:**  ${ step.alias }`;
			}

			aliases += '\n\n';
		}

		output += aliases;


		if (step.inputs && step.inputs.length) {
			output += `**Inputs**\n>\n`;

			for (let i = 0; i < step.inputs.length; i++) {
				output += `> ${ i + 1 }. ${ renderInput(step.inputs[i]) }\n`;
			}

			output += `>\n\n`;
		}

		if (step.output) {
			const out = (Array.isArray(step.output)) ? step.output.join(' | ') : step.output;

			output += `**Output:** \`${ out }\`\n`;
		}
		
		output += `\n`;

		if (step.options && step.options.length) {
			output += `**Options**\n>\n`;

			for (const option of step.options) {
				output += renderOption(option);
			}
		}

		if ((category.options && category.options.length) || (globalProps && globalProps.options && globalProps.options.length)) {
			output += `\n**Shared options**\n>\n`;
			
			if (category.options && category.options.length) {
				output += `> <details open><summary>${ category.name } options</summary>\n> \n`;
				output += `> The following option${ (category.options.length === 1) ? ' is' : 's are' } available on all ${ category.name } steps.\n>\n`;
		
				for (const option of category.options) {
					output += `> * [${ option.name }](#${ adoSlug(option.name) })\n`;
				}
				
				output += `>\n>\n></details>\n>\n`;
			}

			if (globalProps && globalProps.options && globalProps.options.length) {
				output += `> <details><summary>Global options</summary>\n> \n`;
				output += `> The following option${ (globalProps.options.length === 1) ? ' is' : 's are' } available globally on all steps.\n>\n`;
		
				for (const option of globalProps.options) {
					output += `> * [${ option.name }](./index.md#${ adoSlug(option.name) })\n`;
				}
				
				output += `>\n>\n></details>\n>\n`;
			}
		}

		if (step.description) {
			output += '\n\n' + step.description;
		}

		output += `\n\n---\n\n`;
	}

	return output;
};

const renderInput = (input) => {
	const types = (Array.isArray(input.type)) ? input.type.join(' | ') : input.type;
	const desc = (input.description) ? ' ' + input.description : '';
	const optional = (input.optional) ? ' (optional)' : '';

	return `\`${ types }\`${ desc }${ optional }`
}

const renderOption = (option, parentNames = [], isLast = false) => {
	const types = (Array.isArray(option.type)) ? option.type.join(' | ') : option.type;

	const path = [...parentNames, option.name];
	let output = markdownFmt`
		> #### ''${ path.join('.') }''
		>
		> **Type:** ''${ types }''  
		> **Required:** ''${ (option.required) ? 'True' : 'False' }''  
	`;

	output += '\n';

	if (option.enum) output += `> **Allowed values:** \`${ option.enum.join(' | ') }\`  \n`;
	if (option.default) output += `> **Default value:** \`${ option.default }\`  \n`;

	if (option.description) {
		// Each line should start on a chevron.
		output += `>\n${ option.description.split('\n\n').map(d => '> ' + d.split(/\n/g).join('\n> ')).join('\n>\n') }`;
	}

	if (option.children?.length) {
		output += '>\n>\n> **Child options:**\n>\n>';

		for (const childOption of option.children) {
			output += `\n> ${ renderOption(childOption, path, childOption === option.children[option.children.length - 1]).replace(/\n>/g, '\n> >') }`;
		}

		if (!isLast) {
			if (parentNames?.length) {
				output += `\n>\n>`;
			}
			else {
				output += `\n>\n`;
			}
		}
		else {
			output += `\n>`;
		}
	} 
	else if (isLast) {
		output += `\n>`;
	}
	else if (parentNames?.length) {
		output += `\n>\n>`;
	}
	else {
		output += `\n>\n`;
	}

	return output;
}

module.exports = {
	renderStepIndexPage,
	renderStepCategoryPage,
	kebabCase,
};
